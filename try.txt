import jwt from "jsonwebtoken";
import { createError } from "../utils/error.js";
import  config  from '../utils/config.js';

// export const verifyToken = (req, res, next)=>{
//     const token = req.cookies.access_token;
//     if(!token){
//         return next(createError(401, "You are not authenticated!"))
//     }

//     jwt.verify(token,config.JWT_SECRET,(err, user)=>{
//     if(err)  return next(createError(403, "Token is not Valid!"))
//         req.user = user;
//         next()
//     })
// }


// export const verifyOwner  = (req, res, next)=>{
//         if (req.user.id === req.params.id && req.user.isVerified) {
//              next() 
//         }else {
//             return next(createError(403, "You are not Authorized!"))
//         }
    
// }

// export const verifyAdmin  = (req, res, next)=>{
//         if (req.user.isAdmin) {
//              next() 
//         }else {
//             return next(createError(403, "You are not Authorized!"))
//         }
// }


export const generateToken = (user) => {
    return jwt.sign(
      {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phoneNumber: user.phoneNumber,
        isAdmin: user.isAdmin,
      },
      config.JWT_SECRET
    );
  };
  




  
  export const verifyToken = (req, res, next) =>{
    const BearerToken = req.headers.authorization
    if(!BearerToken){
      res.status(401).json({message: 'Token is not supplied'})
    }else{
      const token = BearerToken.slice(7, BearerToken.length)
      jwt.verify(token, config.JWT_SECRET,(err, data)=>{
          if(err){
            res.status(401).json({message: 'Invalid Token'})
          }else{
            req.user = data
            next()
          }
      })
    }
  }
  
  export const  verifyAdmin  = (req, res, next) =>{
    if(req.user && req.user.isAdmin){
      next()
    }else{
      res.status(401).send({message: 'Token is not valid for Admin User'})
    }
  
  }














import Owner from "../models/ownerModel.js";
import User from "../models/userModel.js";
import bcrypt from "bcryptjs";
import { createError } from "../utils/error.js";
import  config  from '../utils/config.js';
import { generateToken } from "../utils/verifyToken.js";


//Only Owner sections
export const ownerRegister  = async (req, res, next)=>{
    try {
        const salt = bcrypt.genSaltSync(10)
        const hash = bcrypt.hashSync(req.body.password, salt)

        const newOwner = new Owner({
            ...req.body,
            password:hash,
        })
        await newOwner.save()
        res.status(200).json({message: "Property Owner has been created."})
    } catch (err) {
        next(err)
    }
}

export const ownerLogin  = async (req, res, next)=>{
    try {
        const  owner = await Owner.findOne({email:req.body.email}) 
        if(!owner) return next(createError(404, "User not found"))
        const  isPasswordCorrect = await bcrypt.compare(req.body.password, owner.password)
        if(!isPasswordCorrect) return next(createError(400, "Wrong password or Email!"))

         const maxAge = 3 * 60 * 60;
         const token = jwt.sign(
            {id: owner._id, isVerified: owner.isVerified},
            config.JWT_SECRET,
                {expiresIn: maxAge, // 3hrs in sec
                }
         )
       
        const {password, isVerified, ...otherDetails } = owner._doc
        res
        .cookie("access_token", token, {
            httpOnly: true,
            maxAge: maxAge * 1000, // 3hrs in ms
        })
        .status(200)
        .json({details:{...otherDetails}, isVerified})
    } catch (err) {
        next(err)
    }
} 

//Only Users/Admin sections
export const userRegister  = async (req, res, next)=>{
    try {
        const salt = bcrypt.genSaltSync(10)
        const hash = bcrypt.hashSync(req.body.password, salt)
        // const { first_name, last_name, email, password } = req.body;

        const newOwner = new User({
            ...req.body,
            password:hash,
        })
        await newOwner.save()
        res.status(200).json({message: "User has been created."})
    } catch (err) {
        next(err)
    }
}

export const userLogin  = async (req, res, next)=>{
    try {
        const  SigninUser = await User.findOne({email:req.body.email}) 
        if(!SigninUser) return next(createError(404, "User not found"))
        const  isPasswordCorrect = await bcrypt.compare(req.body.password, SigninUser.password)
        if(!isPasswordCorrect) return next(createError(400, "Wrong password or Email!"))

        //  const token = jwt.sign(
        //     {id: user._id, isAdmin: user.isAdmin},
        //     config.JWT_SECRET
        //  )
       
        // const {password, isAdmin, ...otherDetails } = user._doc
        res
        .status(200)
        .send({  _id: SigninUser._id,
            firstName: SigninUser.firstName,
            lastName: SigninUser.lastName,
            email: SigninUser.email,
            phoneNumber: SigninUser.phoneNumber,
            isAdmin: SigninUser.isAdmin,
            token: generateToken(SigninUser)})
    } catch (err) {
        next(err)
    }
} 





{
  "name": "awuf-booking-api",
  "version": "1.0.0",
  "description": "Awuf-Booking-Api-v1",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "node index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.20.1",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "jsonwebtoken": "^8.5.1",
    "mongoose": "^6.7.1",
    "nodemon": "^2.0.20",
    "passport": "^0.6.0",
    "passport-google-oauth2": "^0.2.0"
  },
  "engine": {
    "node": "14.x"
  }
}



